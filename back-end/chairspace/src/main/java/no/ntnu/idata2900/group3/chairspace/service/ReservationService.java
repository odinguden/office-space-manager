package no.ntnu.idata2900.group3.chairspace.service;

import java.time.Duration;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.YearMonth;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import no.ntnu.idata2900.group3.chairspace.dto.reservation.ReservationCreationDto;
import no.ntnu.idata2900.group3.chairspace.dto.reservation.ReservationDto;
import no.ntnu.idata2900.group3.chairspace.entity.Area;
import no.ntnu.idata2900.group3.chairspace.entity.Reservation;
import no.ntnu.idata2900.group3.chairspace.entity.User;
import no.ntnu.idata2900.group3.chairspace.exceptions.ElementNotFoundException;
import no.ntnu.idata2900.group3.chairspace.exceptions.InvalidArgumentCheckedException;
import no.ntnu.idata2900.group3.chairspace.exceptions.NotReservableException;
import no.ntnu.idata2900.group3.chairspace.exceptions.ReservedException;
import no.ntnu.idata2900.group3.chairspace.repository.ReservationRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * Service class for managing and interacting with reservations.
 */
@Service
public class ReservationService {
	/**
	 * The amount of milliseconds in a single full day.
	 */
	public static final int MS_IN_DAY = 24 * 60 * 60 * 1000;

	@Autowired
	UserService userService;
	@Autowired
	AreaService areaService;
	@Autowired
	ReservationRepository reservationRepository;

	/**
	 * No args constructor for JPA.
	 */
	public ReservationService() {
		// No args constructor for JPA.
	}

	/**
	 * Gets a reservation DTO by id.
	 *
	 * @param id the id of the reservation to get a DTO of
	 * @return the reservation with the id as a DTO
	 * @throws ElementNotFoundException if there is no item with the given ID
	 */
	public ReservationDto getReservationById(UUID id) throws ElementNotFoundException {
		Optional<Reservation> reservation = reservationRepository.findById(id);
		if (!reservation.isPresent()) {
			throw ElementNotFoundException.RESERVATION_NOT_FOUND;
		}

		return new ReservationDto(reservation.get());
	}

	/**
	 * Gets all reservations belonging to a given user ID.
	 *
	 * @param userId the id of the user to get the reservations of
	 * @return a list of reservation DTOs belonging to the given user id.
	 */
	public List<ReservationDto> getReservationsByUserId(UUID userId) {
		List<Reservation> reservations = reservationRepository
			.findAllByUserOrderByStartDateTimeAsc(userId);

		return reservations.stream().map(ReservationDto::new).toList();
	}

	/**
	 * Creates a reservation for the given area and user.
	 *
	 * @param areaId the id of the area to reserve
	 * @param userId the id of the user reserving the area
	 * @param start the start date and time of the reservation
	 * @param end the end date and time of the reservation
	 * @param comment a comment for the reservation
	 * @return the created reservation
	 * @throws InvalidArgumentCheckedException if the area or user is not found
	 * @throws IllegalArgumentException if the start date and time is after the end date and time
	 * @throws ReservedException if the area is already reserved for the given time period
	 * @throws NotReservableException if the area is not reservable
	 */
	public Reservation createReservation(
		UUID areaId,
		UUID userId,
		LocalDateTime start,
		LocalDateTime end,
		String comment
	) throws InvalidArgumentCheckedException, ReservedException, NotReservableException {
		if (!reservationRepository.isTimeSlotFree(areaId, start, end)) {
			throw ReservedException.reservationOverlapException();
		}

		Area area = areaService.getArea(areaId);
		User user = userService.getEntity(userId);

		return new Reservation(area, user, start, end, comment);
	}

	/**
	 * Automatically creates a reservation based on a DTO.
	 *
	 * @param dto the data transfer object to create the reservation from
	 * @return a reservation as generated by the dto
	 * @throws InvalidArgumentCheckedException if any of the values in the DTO are invalid
	 * @throws ReservedException if the reservation would overlap with an existing one
	 * @throws NotReservableException if the reservation is made for an area that does not allow
	 *     reservations to be made.
	 */
	public Reservation createReservationByCreationDto(ReservationCreationDto dto)
		throws InvalidArgumentCheckedException, ReservedException, NotReservableException {
		return this.createReservation(
			dto.getArea(),
			dto.getUser(),
			dto.getStartTime(),
			dto.getEndTime(),
			dto.getComment()
		);
	}

	/**
	 * Attempts to delete a reservation by its id.
	 *
	 * @param id the id of the reservation
	 * @return true if the reservation was deleted
	 */
	public boolean deleteReservation(UUID id) {
		boolean isDeletable = reservationRepository.existsById(id);
		reservationRepository.deleteById(id);
		return isDeletable;
	}

	/**
	 * Gets all the reservations that exist for an area within the specified time period.
	 *
	 * @param areaId the id of the area to get the time from
	 * @param from the start time to get reservations from
	 * @param until the end time to get reservations until
	 * @return a list containing all reservations that exist within the specified time period
	 *     for the given room
	 */
	public List<ReservationDto> getReservationsForAreaInTimePeriod(
		UUID areaId,
		LocalDateTime from,
		LocalDateTime until
	) {
		List<Reservation> rawList = reservationRepository
			.findReservationsForAreaInTimePeriod(areaId, from, until);

		return rawList.stream()
			.map(ReservationDto::new)
			.toList();
	}

	/**
	 * Gets the percentage of a day that an area is occupied by reservations.
	 *
	 * @param areaId the id of the area
	 * @param day the day to check the reservation frequency of
	 * @return the percentage of the day an area is occupied, as a decimal
	 * @see #getReservationFrequencyForMonth(UUID, YearMonth)
	 */
	public float getReservationFrequencyForDay(UUID areaId, LocalDate day) {
		LocalDateTime startOfDay = day.atStartOfDay();
		LocalDateTime endOfDay = day.plusDays(1).atStartOfDay();

		List<Reservation> reservationsForDay = reservationRepository
			.findReservationsForAreaInTimePeriod(areaId, startOfDay, endOfDay);

		float totalMilliseconds = 0;

		for (Reservation reservation : reservationsForDay) {
			LocalDateTime clampedStartTime = clampTime(reservation.getStart(), startOfDay, null);
			LocalDateTime clampedEndTime = clampTime(reservation.getEnd(), null, endOfDay);

			totalMilliseconds += getMillisBetween(clampedStartTime, clampedEndTime);
		}

		return totalMilliseconds / MS_IN_DAY;
	}

	/**
	 * Gets the percentage of a month that an area is occupied by reservations.
	 *
	 * @param areaId the id of the area
	 * @param year the year to which the month belongs
	 * @param month the month to check the reservation frequency of
	 * @return the percentage of the day an area is occupied, as a decimal
	 * @see #getReservationFrequencyForDay(UUID, LocalDate)
	 */
	public float getReservationFrequencyForMonth(UUID areaId, int year, int month) {
		// Note: Month is 1-indexed (range of 1 to 12)
		YearMonth yearMonth = YearMonth.of(year, month);
		int lengthOfMonth = yearMonth.lengthOfMonth();

		// We use a higher intermediary precision to increase accuracy
		// as floats lose accuracy as numbers grow large.
		double millisecondsInMonth = (MS_IN_DAY * lengthOfMonth);
		double totalMilliseconds = 0;

		for (int day = 1; day <= yearMonth.lengthOfMonth(); day++) {
			LocalDate thisDate = LocalDate.of(year, month, day);

			totalMilliseconds += getReservationFrequencyForDay(areaId, thisDate);
		}

		return (float) (totalMilliseconds / millisecondsInMonth);
	}

	/**
	 * Clamps the time to a minimum and maximum time.
	 *
	 * @param time the time to be clamped
	 * @param min the lowest permissible value for the time. If missing, does not enforce a boundary
	 * @param max the highest permissible value for the time. If missing, does not enforce a
	 *     boundary
	 * @return the time clamped between min and max.
	 */
	private LocalDateTime clampTime(LocalDateTime time, LocalDateTime min, LocalDateTime max) {
		// Multiple returns. Your mom.
		if (min != null && time.isBefore(min)) {
			return min;
		} else if (max != null && time.isAfter(max)) {
			return max;
		}
		return time;
	}

	private float getMillisBetween(LocalDateTime start, LocalDateTime end) {
		Duration duration = Duration.between(start, end);

		return duration.toMillis();
	}
}
